# Claude Code Router - 架构概述

本文档提供了 `claude-code-router` 项目架构的高级概述。它面向希望了解项目工作原理、如何贡献或如何调试的开发人员。

## 1. 核心概念

`claude-code-router` 是一个复杂的本地代理服务器，旨在拦截来自 AI 编码助手客户端（如官方 Claude Code 扩展）的请求，并根据用户定义的配置将其智能地路由到各种其他大型语言模型 (LLM) 提供商。

其主要目标是：
- **灵活性**：打破对 Anthropic 官方模型的依赖，允许使用任何兼容的 LLM API（例如 OpenAI、DeepSeek、Google Gemini、通过 Ollama 的本地模型）。
- **成本效益**：能够将任务路由到更便宜或自托管的模型，从而显著降低运营成本。
- **智能调度**：为不同类型的任务使用不同的模型（例如，强大的模型用于复杂推理，小型本地模型用于后台索引），以优化性能和成本。
- **无缝集成**：通过完美模仿官方 Claude Code API 端点，无需修改客户端应用程序即可工作。

## 2. 项目结构

项目在逻辑上分为两个主要部分：

1.  **应用程序层 (`src/`)**：这是操作的“大脑”。它包含了 `claude-code-router` 的所有特定逻辑，例如命令行处理、配置加载和核心路由规则。
2.  **框架层 (`llms-src/`)**：这是“身体”或“引擎”。它是一个通用、可重用的 LLM 代理框架 (`@musistudio/llms`)，负责处理创建服务器和与各种下游 LLM API 通信的所有底层繁重工作。

这种关注点分离使代码库保持干净、模块化且易于维护。

## 3. 代码流程和组件分析

当用户运行 `ccr code "some instruction"` 时，将触发以下事件序列：

### 步骤 1: 命令行界面 (`src/cli.ts`)

-   这是用户的主要入口点。
-   它使用 `switch` 语句来解析 `start`、`stop`、`status` 和 `code` 等命令。
-   对于 `code` 命令，它使用 `src/utils/processCheck.ts` 中的 `isServiceRunning()` 检查后台服务是否已运行。
-   如果服务未运行，它会巧妙地将自身置于分离的后台进程 (`ccr start`) 中，以确保服务器可用。
-   最后，它将用户的提示传递给 `executeCodeCommand()`，后者将请求发送到正在运行的服务器。

### 步骤 2: 服务编排 (`src/index.ts`)

-   `run()` 函数是服务启动过程的核心。
-   **初始化**：它执行多项设置任务：
    -   `initializeClaudeConfig()`：创建一个假的 `~/.claude.json` 文件，以欺骗客户端认为它已正确配置。
    -   `initDir()` & `initConfig()`：确保 `~/.claude-code-router/` 目录及其 `config.json` 文件存在并已加载。
-   **进程管理**：它保存服务器的进程 ID (PID)，并设置信号处理程序 (`SIGINT`、`SIGTERM`) 以确保干净关闭。
-   **服务器创建**：它调用 `src/server.ts` 中的 `createServer()` 来实例化底层 HTTP 服务器。
-   **“大脑”注入（关键步骤）**：它使用 `server.addHook("preHandler", ...)` 将 `src/utils/router.ts` 中的 `router` 函数注入服务器的请求生命周期。这意味着 **每一个** 命中服务器的请求，在执行其他任何操作之前，都会先由 `router` 函数处理。
-   **服务器启动**：它调用 `server.start()` 开始监听 HTTP 请求。

### 步骤 3: 服务器抽象 (`src/server.ts`)

-   此文件非常简单，但揭示了一个关键的架构决策。
-   它不是从头开始实现服务器。相反，它从本地模块 `@musistudio/llms`（指向 `llms-src/` 目录）导入一个 `Server` 类。
-   这表明所有通用的服务器和 LLM 通信逻辑都委托给了这个可重用的框架。

### 步骤 4: 智能路由器 (`src/utils/router.ts`)

这是应用程序逻辑中最关键的部分。它是第 2 步中注入的“大脑”。当来自 Claude Code 客户端的请求到达时，此函数会执行：

1.  **令牌计算**：它仔细计算传入请求中的令牌总数，包括系统提示、消息历史和工具定义。它使用 `tiktoken` 的 `cl100k_base` 编码，这是许多现代模型使用的标准。
2.  **路由逻辑 (`getUseModel`)**：它按特定的优先级顺序应用一系列规则来决定使用哪个模型：
    1.  **手动覆盖**：如果请求中的模型名称包含逗号（例如，来自 `/model provider,model_name` 命令），则该选择高于一切。
    2.  **长上下文**：如果令牌数超过阈值（例如 60k），则路由到配置中指定的 `Router.longContext` 模型。
    3.  **后台任务**：如果请求来自 `claude-3-5-haiku` 等模型（可能是后台任务），则路由到 `Router.background` 模型。
    4.  **思考任务**：如果请求体包含 `thinking` 标志，则路由到 `Router.think` 模型。
    5.  **默认**：如果以上条件均不满足，则回退到 `Router.default` 模型。
3.  **请求修改**：做出决定后，该函数会就地修改请求体：`req.body.model = model;`。它用路由逻辑选择的模型替换原始模型名称。

修改后的请求随后会传递给底层的 `@musistudio/llms` 框架，该框架负责处理与最终目的地（例如 DeepSeek API）的实际通信。

## 4. 结论

`claude-code-router` 是一个架构良好的应用程序，展示了清晰的关注点分离。它将通用的 LLM 框架与高度特定和智能的路由层相结合。其逻辑集中在 `router.ts` 中间件中，使得在不接触底层服务器基础设施的情况下，易于理解、调试和扩展路由规则。